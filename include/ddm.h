#ifndef DDM_CUH
#define DDM_CUH

#include <vector> 
#include <string> 
#include <functional> 
#include <tuple>
#include <map> 
#include "mle_info.h"

using namespace std; 


/**
 * @brief Implementation of a single DDMTrial object
 * 
 * A DDMTrial can either be generated by simulating data trials or loading from a CSV. A single 
 * trial represents an individual binary perceptual choice made by one subject. These trials 
 * be aggregated together for model fitting and likelihood computations. 
 * 
 */
class DDMTrial {
    private:
    public:
        unsigned int RT; /**< Response time in milliseconds. */
        int choice; /**< Either -1 for the left item or +1 for the right item. */
        int valueLeft; /**< Value of the left item. */
        int valueRight; /**< Value of the right items. */
        vector<float>RDVs; /**< The RDV signal recorded at each timestep. */
        int timeStep; /**< The length of each timestep in milliseconds. */

        /**
         * @brief Construct a new DDMTrial object.
         * 
         * @param RT Response time in milliseconds. 
         * @param choice Either -1 for the left item or +1 for the right item. 
         * @param valueLeft Value of the left item.
         * @param valueRight Value of the right item. 
         */
        DDMTrial(unsigned int RT, int choice, int valueLeft, int valueRight);

        /**
         * @brief Construct an empty DDMTrial object. 
         * 
         */
        DDMTrial() {};

        /**
         * @brief Write a vector of DDMTrials to a CSV file. 
         * 
         * @param trials Vector of trials to be saved. 
         * @param filename File to store the trials in. 
         */
        static void writeTrialsToCSV(vector<DDMTrial> trials, string filename);

        /**
         * @brief Load a dataset of DDMTrials into program memory. 
         * 
         * @param filename Location of the data trials. 
         * @return vector<DDMTrial> containing the stored trials. 
         */
        static vector<DDMTrial> loadTrialsFromCSV(string filename);
};

/**
 * @brief Implementation of the Drift Diffusion Model (DDM).
 * 
 * This class contains an implementation of the Drift Diffusion Model (DDM) as described by 
 * Ratcliff et al. (1998). This class provides methods for data simulation and model fitting via
 * Maximum Likelihood Estimation. The processes of model fiting involves selecting some range of
 * potential parameters (d, sigma) and iterating over the parameter space to determine which 
 * combination best fits the provided set of DDMTrials. For details on the simulation and model 
 * fitting process, see the individual methods described below. 
 */
class DDM {
    private:
#ifndef EXCLUDE_CUDA_CODE
        void callGetTrialLikelihoodKernel(
            bool debug, 
            int trialsPerThread, int numBlocks, int threadsPerBlock, 
            DDMTrial *trials, double *likelihoods, int numTrials, 
            float d, float sigma, float barrier, 
            int nonDecisionTime, int timeStep, float approxStateStep, float dec);
#endif 
        

    public: 
        float d; /**< Float parameter of the model that controls the speed of integration. Referred
            to as drift rate. */
        float sigma; /**< Float parameter of the model that control noise of the RDV signal and 
            standard deviation for any sampled normal distributions. */
        float barrier; /**< Positive float representing the magnitude of the signal threshold. */
        unsigned int nonDecisionTime; /**< Non-negative integer representing the amount of time in 
            milliseconds in which only noise is added to the decision variable. */
        float bias; /**< Float corresponding to the initial RDV. Must be smaller than the 
            barrier. */
        float decay; /**< Parameter that controls the decay of the barriers over time. A decay of 
            zero means the barriers are constant. */

        bool operator <( const DDM &rhs ) const { 
            return (d * 17) + (sigma * 31) + (bias * 43) + (decay * 59) < 
                (rhs.d * 17) + (rhs.sigma * 31) + (rhs.bias * 43) + (rhs.decay * 59);
        }

        bool operator ==( const DDM &rhs ) const {
            return (rhs.d == d) && (rhs.sigma == sigma);
        }

        /**
         * @brief Construct a new DDM object.
         * 
         * @param d Drift rate. 
         * @param sigma Noise or standard deviation for the normal distribution. 
         * @param barrier Positive magnitude of the signal threshold. 
         * @param nonDecisionTime Amount of time in milliseconds in which only noise is added to 
         * the decision variable. 
         * @param bias Corresponds to the initial value of the decision variable. Must be smaller
         * than the barrier.
         * @param decay Controls the decay of the RDV barriers over time.  
         */
        DDM(float d, float sigma, float barrier=1, unsigned int nonDecisionTime=0, 
            float bias=0, float decay=0);

        /**
         * @brief Construct an empty DDM object. 
         * 
         */
        DDM() {}

        /**
         * @brief Export the data pertaining to a single DDM and DDMTrial to a JSON file. 
         * 
         * @param dt Trial to export
         * @param filename File to store the trial information in. 
         */
        void exportTrial(DDMTrial dt, std::string filename); 

        /**
         * @brief Compute the likelihood of the trial results provided the current parameters. 
         * 
         * @param trial DDMTrial object. 
         * @param debug Boolean specifying if state variables should be printed for debugging 
         * purposes. 
         * @param timeStep Value in milliseconds used for binning the time axis. 
         * @param approxStateStep Used for binning the RDV axis. 
         * @return double representing the likelihood for the given trial. 
         */
        double getTrialLikelihood(
            DDMTrial trial, bool debug=false, int timeStep=10, float approxStateStep=0.1);

        /**
         * @brief Generate a simulated DDM trial provided item values. 
         * 
         * @param valueLeft Value of the left item. 
         * @param valueRight Value of the right item. 
         * @param timeStep Value in milliseconds used for binning the time axis. 
         * @param seed used for standardizing any random number generators. 
         * @return DDMTrial resulting from the simulation. 
         */
        DDMTrial simulateTrial(int valueLeft, int valueRight, int timeStep=10, int seed=-1);

        /**
         * @brief Compute the total Negative Log Likelihood (NLL) for a vector of DDMTrials. Use 
         * CPU multithreading to maximize the number of blocks of trials that can have their 
         * respective NLLs computed in parallel. 
         * 
         * @param trials Vector of DDMTrials that the model should calculate the NLL for. 
         * @param debug Boolean specifying if state variables should be printed for debugging 
         * purposes. 
         * @param timeStep Value in milliseconds used for binning the time axis. 
         * @param approxStateStep Used for binning the RDV axis. 
         * @return ProbabilityData containing NLL, sum of likelihoods, and a list  of all computed 
         * likelihood. 
         */
        ProbabilityData computeParallelNLL(
            vector<DDMTrial> trials, bool debug=false, int timeStep=10, float approxStateStep=0.1);

#ifndef EXCLUDE_CUDA_CODE
        /**
         * @brief Compute the total Negative Log Likelihood (NLL) for a vector of DDMTrials. Use
         * the GPU to maximize the number of trials being computed in parallel. 
         * 
         * @param trials Vector of DDMTrials that the model should calculate the NLL for. 
         * @param debug Boolean specifying if state variables should be printed for debugging 
         * purposes. 
         * @param trialsPerThread Number of trials that each thread should be designated to 
         * copmute. Must be divisible by the total number of trials. 
         * @param timeStep Value in milliseconds used for binning the time axis. 
         * @param approxStateStep Used for binning the RDV axis. 
         * @return ProbabilityData containing NLL, sum of likelihoods, and a list  of all computed 
         * likelihood. 
         */
        ProbabilityData computeGPUNLL(
            vector<DDMTrial> trials, bool debug=false, int trialsPerThread=10, 
            int timeStep=10, float approxStateStep=0.1);
#endif 

        /**
         * @brief Copmlete a grid-search based Maximum Likelihood Estimation of all possible 
         * paramters combinations (d, sigma) to determine which parameters are most likely to 
         * generate the provided DDMTrials. Each potential model generates an NLL value for the 
         * dataset and the method returns the model with the minimum NLL value. 
         * 
         * @param trials Vector of DDMTrials that each model should calculate the NLL for. 
         * @param rangeD Vector of floats representing possible values of d to dest for. 
         * @param rangeSigma Vector of floats representing possible values of sigma to test for. 
         * @param computeMethod Computation method to calculate the NLL for each possible model.
         * Allowed values are {basic, thread, gpu}. "basic" will compute each trial likelihood 
         * sequentially and compute the NLL as the sum of all negative log likelihoods. "thread" 
         * will use a thread pool to divide all trials into the maximum number of CPU threads and
         * compute the NLL of each block of trials in parallel. "gpu" will call a CUDA kernel to 
         * compute the likelihood of each trial in parallel on the GPU. 
         * @param normalizePosteriors true if the returned MLEinfo should contain a mapping of aDDMs 
         * to the normzlied posteriors distribution for each model; otherwise, the MLEinfo should 
         * containing a mapping of aDDMs to its corresponding NLL. 
         * @param barrier Positive magnitude of the sigmal threshold.
         * @param nonDecisionTime Amount of time in milliseconds in which only noise is added to 
         * the decision variable. 
         * @param bias Corresponds to the initial RDV. Must be smaller than the barrier. Possible 
         * input forms are: (1) No input - the standard bias of 0 is assumed for all potential 
         * DDM models to check. (2) Single input (vector with one element) - i.e. {0.03} - the 
         * specified input bias is assumed for all potential models. (3) Range of inputs - i.e. 
         * {-0.12, 0, 0.12} - the input range is processed as another dimension to check and a 
         * new set of models will be tested with all possible combinations of biases. 
         * @param decay Corresponds to the decay of the barriers over time. A decay of zero
         * means that the barriers are constant. Similar to the `bias` argument, the three 
         * input forms of no input, a vector with single element, and a vector with a range of 
         * elements. 
         * @return MLEinfo containing the most optimal model and a mapping of models to floats 
         * determined by the normalizePosteriors argument. 
         */
        static MLEinfo<DDM> fitModelMLE(
            vector<DDMTrial> trials, vector<float> rangeD, vector<float> rangeSigma, 
            string computeMethod="basic", bool normalizePosteriors=false, float barrier=1, 
            unsigned int nonDecisionTime=0, vector<float> bias={0}, vector<float> decay={0}
        );
};

#endif